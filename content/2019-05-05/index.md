---
title: "Isomorphic Clojure?"
date: "2019-05-05"
category: "tech"
cover: https://clojure.org/index
tags:
    - clojure
    - clojurescript
---

이전 글에서는 실시간 웹을 구현하기 위해서 Elixir를 배워보기로 했었다. 그런데 회사에서 Clojure를 쓰고 있기도 하고, 서버 Clojure + 클라이언트 ClojureScript 조합이 괜찮을 것 같아서 이 쪽도 시도해봤다.

결론부터 말하자면 개발 경험이 그다지 좋지 않았다. 그래서 계획대로 Elixir 기반으로 공부를 시작하되, 클라이언트와 서버에 같은 모델을 써야 하는 경우는 Node.js 기반 워커를 추가로 붙이는 식으로 시도해볼 계획이다.

## Clojure + ClojureScript = ?

다니는 회사에서 Clojure로 백엔드 개발을 하고 있고 나도 여기에 차츰 발을 담구고 있는 과정에 있다. 그래서 이 쪽으로도 시도를 해 볼 가치가 있다고 느꼈다.

일단 Clojure로 실시간 웹을 구현하게 되면 서버와 클라이언트를 같은 언어로 구현할 수 있다는 장점이 생긴다. ClojureScript는 JavaScript로 컴파일되는 Clojure의 변종이고, 근래 JavaScript 개발 생태계에 끼친 영향도 크다. (JavaScript 생태계에 여러 함수형 프로그래밍 패러다임의 도입을 촉진시킨 것으로 안다.) Clojure 컴파일러는 JVM Clojure와 ClojureScript에서 모두 실행할 수 있는 파일 형식인 `.cljc`를 지원하므로, 서버와 클라이언트에 모두 필요한 코드를 이 포맷으로 작성할 수 있다.

서버와 클라이언트를 같은 언어로 구현할 수 있다는 것은 꽤나 큰 장점으로 보인다. 어쨌든 실시간 협업에서는 서버와 클라이언트 간의 상태의 동기화 작업이 필요할 텐데, 여기에 쓰이는 모델 코드를 두 번 작성하지 않아도 된다는 점이 큰 장점으로 다가왔다.

## Clojure + Async = ?

실시간 웹을 개발한다는 것은 필히 많은 수의 WebSocket 연결을 들고있어야 한다는 전제를 깔고 있으므로, 서버 환경에서 비동기를 잘 지원하는지의 여부는 중요하다. (동기식 API만을 사용해야 한다면 "1 연결 = 1 스레드"를 필히 수반하므로 서버의 메모리가 금방 가득 차버릴 것이다.)

Clojure는 여러 환경에서 구동될 수 있지만, 어쨌든 JVM 위에서 구동하는 경우가 가장 많아서 네트워킹 관련 라이브러리들은 대개 JVM을 가정하고 만들어져 있다.

JVM에서는 동기식 I/O와 비동기식 I/O를 둘 다 지원한다. (정확히는 동기식 I/O만 지원하다가 나중에 비동기식 I/O가 추가되었다.) 그래서 동기식 API만 쓰거나 (Ruby, asyncio 도입 전의 Python), 비동기식 API만 쓰는 환경에 (Node.js) 익숙한 나로서는 처음에 이 부분을 이해하기가 좀 힘들었다.

Clojure는 Go가 널리 퍼뜨린 '경량 스레드 + 채널' 방식의 비동기 프로그래밍을 잘 지원한다. 하지만 기존의 JVM 생태계 중 아직도 어쩔 수 없이 동기식 API를 써야 하는 부분(JDBC 등)이 존재한다. 이 때 비동기 프로그래밍을 하고 싶다면, 동기식 API를 쓸 때에만 별도의 처리를 해주어야 한다. (스레드를 매번 생성하거나, 전용 스레드풀을 직접 관리하거나, 비동기식으로 래핑한 라이브러리를 사용하거나) 즉, **개발자는 내가 지금 비동기식 API를 사용하는지, 동기식 API를 사용하는지를 매번 생각하면서 프로그래밍을 해야 한다는 것이다.** 이건 꽤 큰 단점으로 다가왔는데, 일단은 실수할 가능성이 크고, 실수했을 때 발견하기가 쉽지 않으며, 그 실수때문에 생기는 버그가 미묘하지만 작지 않은 성능 장애로 이어질 수 있기 때문이다.

그래서 JVM 위에서 개발을 해야하는 사람의 입장에서는 성능 상 아주 큰 이득이 있지 않는 한 비동기식 API를 사용해야 할 유인이 크지 않으며 (불편하니까), 보통의 경우 동기식 API만 가지고 개발을 하는 쪽을 선택하게 되는 경우가 많은 것 같다. 나 역시 JVM 관련 경험이 미천한 상태에서, 이 부분을 잘 처리하기가 쉽지 않을 것 같았다.

## ClojureScript?

ClojureScript는 ClojureXXX 답게 굉장히 동적인 개발환경을 제공해준다. ([참고 영상](https://www.youtube.com/watch?v=KZjFVdU8VLI&t)) 그리고 Clojure 자체가 함수형 언어이므로 React와의 궁합이 굉장히 잘 맞아서, React를 감싸놓은 유명한 라이브러리가 몇 개나 있을 정도이다. 그 중에 현재는 [Reagent](https://github.com/reagent-project/reagent)가 널리 쓰이는 것 같아서 이것으로 시도를 해봤고, 이 경험은 꽤나 만족스러웠다. (MobX가 아마 이 라이브러리를 모방한 게 아닌가 생각된다.)

JavaScript로 컴파일되는 언어들이 JavaScript interop을 제대로 처리하지 못해서 난감한 경우가 있는데 ClojureScript는 그런 경우도 아니었다. 애초에 Clojure가 Java와의 interop을 염두에 두고 설계된 언어이다 보니, 거의 같은 방식으로 ClojureScript-JavaScript 간 interop이 가능했고, 이 부분은 많은 실험을 해보지는 못했지만 크게 걱정되지는 않았다.

## 구동 시간...

가장 불만스러웠던 부분은 어이없게도 Clojure REPL의 구동 시간이었다. 서버든 클라이언트든 기초적인 템플릿 프로젝트조차 껏다가 켜는데 거의 1분 정도의 시간이 소요되었으며, 주로 스크립트 언어로만 개발을 하던 나에게는 이게 가장 큰 deal breaker였다. Clojure REPL을 켜놓은 상태에서 프로그램을 재시작하는 [프로그래밍 패턴 및 라이브러리](https://github.com/stuartsierra/component)가 있을 정도로 많은 사람들이 같은 어려움을 느끼는 것으로 보인다.
